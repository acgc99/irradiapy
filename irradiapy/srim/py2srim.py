"""This module contains the `Py2SRIM` class."""

# pylint: disable=too-many-lines

import os
import platform
import subprocess
import threading
import time
import traceback
import warnings
from collections import defaultdict
from dataclasses import dataclass, field
from pathlib import Path

import numpy as np
from numpy import typing as npt

from irradiapy import config, dtypes, materials
from irradiapy.materials.component import Component
from irradiapy.recoilsdb import RecoilsDB
from irradiapy.srim.srimdb import SRIMDB

platform = platform.system()
if platform == "Windows":
    import pygetwindow
    import pywinauto
else:
    warnings.warn(
        "SRIM subpackage only works for Windows. " f"'{platform}' not supported."
    )


@dataclass
class Py2SRIM:
    """Base class for running SRIM calculations from Python.

    Attributes
    ----------
    seed : int (default=0)
        Seed for SRIM randomness.
    root_dir: Path
        Root directory where all calculations will be stored.
    srim_target : SRIMTarget
        SRIM target.
    calculation : str
        SRIM calculation.
    srim_dir : Path (default=config.SRIM_DIR)
        Directory where SRIM is installed.
    recoilsdb : RecoilsDB
        Database to store all recoils collected from SPECTRA-PKA and SRIM calculations.
    check_interval : float (default=0.2)
        Interval to check for SRIM window/popups.
    plot_type : int (default=5)
        Plot type during SRIM calculations. 5 for no plots (faster calculations).
    xmin : float (default=0.0)
        Minimum x for plots and depth-dependent means during SRIM calculations. Particularly
        important for large targets, since SRIM divides it in 100 segments.
    xmax : float (default=0.0)
        Maximum x for plots and depth-dependent means during SRIM calculations. Particularly
        important for large targets, since SRIM divides it in 100 segments.
        0.0 for full target.
    do_ranges : int (default=1)
        Whether to save `RANGE.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_backscatt : int (default=1)
        Whether to save `BACKSCAT.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_transmit : int (default=1)
        Whether to save `TRANSMIT.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_sputtered : int (default=1)
        Whether to save `SPUTTER.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_collisions : int (default=1)
        Whether to save `COLLISON.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    exyz : float (default=0.0)
        Whether to save ions position every time they loose `exyz` energy in the `EXYZ.txt` file.
    autosave : int (default=0)
        Autosave every this number of ions. 0 to disable.
    """

    seed: int = 0

    root_dir: Path = field(init=False)
    target: list[Component] = field(init=False)
    calculation: str = field(init=False)
    srim_dir: Path = field(default_factory=lambda: config.SRIM_DIR)
    recoilsdb: RecoilsDB = field(init=False)

    check_interval: float = 0.2
    plot_type: int = 5
    xmin: float = 0.0
    xmax: float = 0.0
    do_ranges: int = 1
    do_backscatt: int = 1
    do_transmit: int = 1
    do_sputtered: int = 1
    do_collisions: int = 1
    exyz: float = 0.0
    autosave: int = 0

    reminders: int = field(default=0, init=False)
    bragg: int = field(default=1, init=False)

    # region SRIM files

    def __generate_trimin(
        self,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
    ) -> None:
        """Generates `TRIM.IN` file."""
        nions = len(atomic_numbers)
        atomic_mass = materials.ATOMIC_WEIGHT_BY_ATOMIC_NUMBER[atomic_numbers[0]]
        energy = np.ceil(energies.max()) / 1e3
        ncomponents = len(self.target)
        nelements = sum(len(component.elements) for component in self.target)
        if self.calculation == "quick":
            calculation = 4
        elif self.calculation == "full":
            calculation = 5
        else:
            calculation = 7

        trimin_path = self.srim_dir / "TRIM.IN"
        with open(trimin_path, "w", encoding="utf-8") as file:
            file.write("TRIM.IN file generated by irradiapy.\n")
            # Ion parameters
            file.write(
                (
                    "ion Z, A, energy, angle, number of ions, Bragg correction, autosave\n"
                    f"{atomic_numbers[0]} {atomic_mass} {energy} 0 "
                    f"{nions} {self.bragg} {self.autosave}\n"
                )
            )
            # Calculation type and seed
            file.write(
                (
                    "calculation, seed, reminders\n"
                    f"{calculation} {self.seed} {self.reminders}\n"
                )
            )
            # Output files
            file.write(
                (
                    "Diskfiles (0=no,1=yes): Ranges, Backscatt, Transmit, Sputtered, "
                    "Collisions(1=Ion;2=Ion+Recoils), Special EXYZ.txt file\n"
                    f"{self.do_ranges} {self.do_backscatt} {self.do_transmit} {self.do_sputtered} "
                    f"{self.do_collisions} {self.exyz}\n"
                )
            )
            # Target material
            file.write(
                (
                    "target material, number of elements, layers\n"
                    f'"irradiapy" {nelements} {ncomponents}\n'
                )
            )
            # Plot settings
            file.write(
                (
                    "PlotType (0-5); Plot Depths: Xmin, Xmax(Ang.) [=0 0 for Viewing Full Target]\n"
                    f"{self.plot_type} {self.xmin} {self.xmax}\n"
                )
            )
            # Target elements
            string = "target element, Z, mass\n"
            for i, component in enumerate(self.target):
                for j, element in enumerate(component.elements):
                    string += (
                        f"Atom {i*len(component.elements)+j+1} = {element.symbol} "
                        f"=      {element.atomic_number} {element.atomic_weight}\n"
                    )
            file.write(string)
            # Target layers
            string = "layer name, width density elements\nnumb. desc. (ang) (g/cm3) stoich.\n"
            layers_info = []
            for i, component in enumerate(self.target):
                prev_stoichs = [0.0] * sum(len(l.elements) for l in self.target[:i])
                next_stoichs = [0.0] * sum(
                    len(l.elements) for l in self.target[i + 1 :]
                )
                layer_info = f'{i} "layer{i}" {component.width} {component.density} '
                layer_info += " ".join(
                    map(str, prev_stoichs + list(component.stoichs) + next_stoichs)
                )
                layers_info.append(layer_info)
            file.write(string + "\n".join(layers_info) + "\n")
            # Phases
            string = "phases\n"
            string += " ".join(map(str, (component.phase for component in self.target)))
            file.write(string + "\n")
            # Bragg
            string = "target compound corrections (bragg)\n"
            string += " ".join(
                map(str, (component.srim_bragg for component in self.target))
            )
            file.write(string + "\n")
            # Displacement energies
            string = "displacement energies (eV)\n"
            string += " ".join(
                map(
                    str,
                    (
                        element.ed_avr
                        for component in self.target
                        for element in component.elements
                    ),
                )
            )
            file.write(string + "\n")
            # Lattice energies
            string = "lattice binding energies (eV)\n"
            string += " ".join(
                map(
                    str,
                    (
                        element.srim_el
                        for component in self.target
                        for element in component.elements
                    ),
                )
            )
            file.write(string + "\n")
            # Binding energies
            string = "surface binding energies (eV)\n"
            string += " ".join(
                map(
                    str,
                    (
                        element.srim_es
                        for component in self.target
                        for element in component.elements
                    ),
                )
            )
            file.write(string + "\n")
            # Stopping power version
            file.write("Stopping Power Version\n0\n")

    def __generate_trimdat(
        self,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        depths: None | npt.NDArray[np.float64] = None,
        ys: None | npt.NDArray[np.float64] = None,
        zs: None | npt.NDArray[np.float64] = None,
        cosxs: None | npt.NDArray[np.float64] = None,
        cosys: None | npt.NDArray[np.float64] = None,
        coszs: None | npt.NDArray[np.float64] = None,
    ) -> npt.NDArray[np.float64]:
        """Generates `TRIM.DAT` file.

        Parameters
        ----------
        atomic_numbers : npt.NDArray[np.int64]
            Atomic numbers.
        energies : npt.NDArray[np.float64]
            Energies.
        depths : npt.NDArray[np.float64] | None  (default=None)
            Depths.
        ys : npt.NDArray[np.float64] | None (default=None)
            Y positions.
        zs : npt.NDArray[np.float64] | None (default=None)
            Z positions.
        cosxs : npt.NDArray[np.float64] | None (default=None)
            X directions.
        cosys : npt.NDArray[np.float64] | None (default=None)
            Y directions.
        coszs : npt.NDArray[np.float64] | None (default=None)
            Z directions.

        Returns
        -------
        npt.NDArray[np.float64]
            `TRIM.DAT` data.
        """
        trimdat_path = self.srim_dir / "TRIM.DAT"
        nions = atomic_numbers.size
        if depths is None:
            depths = np.zeros(nions)
        if ys is None:
            ys = np.zeros(nions)
        if zs is None:
            zs = np.zeros(nions)
        if cosxs is None:
            cosxs = np.ones(nions)
        if cosys is None:
            cosys = np.zeros(nions)
        if coszs is None:
            coszs = np.zeros(nions)
        names = np.array([f"{i:06d}" for i in range(1, nions + 1)], dtype=str)
        with open(trimdat_path, "w", encoding="utf-8") as file:
            file.write("<TRIM>\n" * 9)
            file.write("Name atomic_number E x y z cosx cosy cosz\n")
            for i in range(nions):
                file.write(
                    (
                        f"{names[i]} {atomic_numbers[i]} {energies[i]} {depths[i]} {ys[i]} "
                        f"{zs[i]} {cosxs[i]} {cosys[i]} {coszs[i]}\n"
                    )
                )
        data = np.empty(nions, dtype=dtypes.trimdat)
        for i in range(nions):
            data[i]["name"] = names[i]
            data[i]["atomic_number"] = atomic_numbers[i]
            data[i]["energy"] = energies[i]
            data[i]["pos"] = np.array([depths[i], ys[i], zs[i]])
            data[i]["dir"] = np.array([cosxs[i], cosys[i], coszs[i]])
        return data

    def __generate_trimauto(self) -> None:
        """Generates `TRIMAUTO` file."""
        with open(self.srim_dir / "TRIMAUTO", "w", encoding="utf-8") as file:
            file.write("1\n\nCheck TRIMAUTO.txt for details.\n")

    # endregion

    # region Checks

    def __check_transmit(self, srimdb: SRIMDB) -> None:
        """Checks if there are transmitted ions in the database."""
        transmit_rows = list(srimdb.read("transmit", "atom_numb, energy"))
        if transmit_rows:
            msg = ", ".join(f"({row[0]}, {row[1]:.2g})" for row in transmit_rows)
            raise RuntimeError(
                "SRIM ions ended up transmitted. Consider increasing the "
                "effective target width. (Z, E (eV)) = " + msg
            )

    def __check_backscat(self, srimdb: SRIMDB) -> None:
        """Checks if there are backscattered ions in the database."""
        backscat_rows = list(srimdb.read("backscat", "atom_numb, energy"))
        if backscat_rows:
            msg = ", ".join(f"({row[0]}, {row[1]:.2g})" for row in backscat_rows)
            raise RuntimeError(
                "SRIM ions ended up backscattered. Consider increasing the "
                "effective target width. (Z, E (eV)) = " + msg
            )

    # endregion

    # region Run

    def __create_srimdb(
        self,
        path: Path,
        target: list[Component],
        calculation: str,
    ) -> SRIMDB:
        """Creates a SRIMDB instance."""
        srimdb = SRIMDB(
            path=path,
            target=target,
            calculation=calculation,
            seed=self.seed,
            plot_type=self.plot_type,
            xmin=self.xmin,
            xmax=self.xmax,
            do_ranges=self.do_ranges,
            do_backscatt=self.do_backscatt,
            do_transmit=self.do_transmit,
            do_sputtered=self.do_sputtered,
            do_collisions=self.do_collisions,
            exyz=self.exyz,
            autosave=self.autosave,
        )
        return srimdb

    def __minimize_and_handle_popup(self):
        """Minimizes the SRIM window and handles the end of calculation popup."""
        # pylint: disable=protected-access
        window_title = "SRIM-2013.00"
        popup_title = "End of TRIM.DAT calculation"
        if platform == "Windows":
            # Minimize window
            while True:
                windows = pygetwindow.getWindowsWithTitle(window_title)
                if windows:
                    window = windows[0]
                    app = pywinauto.Application().connect(handle=window._hWnd)
                    app.window(handle=window._hWnd).minimize()
                    break
                time.sleep(self.check_interval)
            # Dismiss popup (quick-calculation does not have this popup)
            if self.calculation != "quick":
                while True:
                    popups = pygetwindow.getWindowsWithTitle(popup_title)
                    if popups:
                        popup = popups[0]
                        app = pywinauto.Application().connect(handle=popup._hWnd)
                        app.window(handle=popup._hWnd).send_keystrokes("{ENTER}")
                        break
                    time.sleep(self.check_interval)
        elif platform == "Linux":
            # Minimize window
            while True:
                windows = pygetwindow.getWindowsWithTitle(window_title)
                if windows:
                    window = windows[0]
                    window_id = window._hWnd  # pylint: disable=protected-access
                    subprocess.run(
                        ["xdotool", "windowminimize", str(window_id)], check=True
                    )
                    break
                time.sleep(self.check_interval)
            # Dismiss popup (quick-calculation does not have this popup)
            if self.calculation != "quick":
                while True:
                    popups = pygetwindow.getWindowsWithTitle(popup_title)
                    if popups:
                        popup = popups[0]
                        popup_id = popup._hWnd  # pylint: disable=protected-access
                        subprocess.run(
                            ["xdotool", "windowactivate", str(popup_id)], check=True
                        )
                        subprocess.run(["xdotool", "key", "Return"], check=True)
                        break
                    time.sleep(self.check_interval)

    @staticmethod
    def __separate_ions_by_atomic_number(
        energy_threshold: float,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        **extra_fields: npt.NDArray[np.float64],
    ) -> dict[int, dict[str, npt.NDArray[np.float64]]]:
        """Group ions by atomic number, keeping only those above the energy threshold.

        Parameters
        ----------
        energy_threshold : float
            Minimum energy (eV) to include an ion in the output.
        atomic_numbers : array_like
            Atomic number of each ion.
        energies : array_like
            Energy (eV) of each ion. Used for thresholding.
        **extra_fields : array_like
            Any extra per-ion arrays to propagate (depths, ys, zs, cosxs, ...).

        Returns
        -------
        dict[int, dict[str, np.ndarray]]
            A dictionary keyed by atomic number. Each value is another dict with:
                'atomic_numbers' : np.ndarray
                'energies'       : np.ndarray
                '<field name>'   : np.ndarray  # for each entry in extra_fields
                'nions'          : int
        """
        if energies.shape != atomic_numbers.shape:
            raise ValueError(
                "`energies` and `atomic_numbers` must have the same shape."
            )

        ions: dict[int, dict[str, npt.NDArray[np.float64]]] = {}
        unique_atomic_numbers = np.unique(atomic_numbers)

        for atomic_number in unique_atomic_numbers:
            mask = (atomic_numbers == atomic_number) & (energies > energy_threshold)
            if not np.any(mask):
                continue

            batch: dict[str, npt.NDArray[np.float64]] = {
                "atomic_numbers": atomic_numbers[mask],
                "energies": energies[mask],
            }
            for name, arr in extra_fields.items():
                batch[name] = arr[mask]
            batch["nions"] = batch["atomic_numbers"].size

            ions[int(atomic_number)] = batch

        return ions

    def __tree2path_db(
        self,
        tree: tuple[int, ...],
        create_parent_dir: bool,
    ) -> Path:
        """Converts a tree tuple into a database path.

        Parameters
        ----------
        tree : tuple[int, ...]
            Tree tuple.
        create_parent_dir : bool
            Whether to create the parent directory.

        Returns
        -------
        Path
            Database path.
        """
        branch_dir = self.root_dir.joinpath(
            *(str(atomic_number) for atomic_number in tree)
        )
        if create_parent_dir:
            branch_dir.mkdir(parents=True, exist_ok=True)
        path = branch_dir / "srim.db"
        return path

    def __run(
        self,
        srimdb: SRIMDB,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        depths: npt.NDArray[np.float64] | None,
        ys: npt.NDArray[np.float64] | None,
        zs: npt.NDArray[np.float64] | None,
        cosxs: npt.NDArray[np.float64] | None,
        cosys: npt.NDArray[np.float64] | None,
        coszs: npt.NDArray[np.float64] | None,
        fail_on_backscat: bool,
        fail_on_transmit: bool,
        ignore_32bit_warning: bool = True,
    ) -> None:
        """Run the SRIM simulation.

        Parameters
        ----------
        srimdb : SRIMDB
            SRIM database.
        atomic_numbers : npt.NDArray[np.int64]
            Ion atomic numbers.
        energies : npt.NDArray[np.float64]
            Ion energies.
        depths : npt.NDArray[np.float64] | None
            Ion initial depths.
        ys : npt.NDArray[np.float64] | None
            Ion initial y positions.
        zs : npt.NDArray[np.float64] | None
            Ion initial z positions.
        cosxs : npt.NDArray[np.float64] | None
            Ion initial x directions.
        cosys : npt.NDArray[np.float64] | None
            Ion initial y directions.
        coszs : npt.NDArray[np.float64] | None
            Ion initial z directions.
        fail_on_backscat : bool
            Whether to fail if there are backscattered ions.
        fail_on_transmit : bool
            Whether to fail if there are transmitted ions.
        """
        if ignore_32bit_warning:
            warnings.filterwarnings(
                "ignore",
                category=UserWarning,
                message="32-bit application should be automated using 32-bit Python",
            )

        if srimdb.table_exists("trimdat"):
            raise RuntimeError(
                (
                    f"The database {srimdb.path} is already populated "
                    "with data from another simulation, use another one."
                )
            )

        # Generate input files
        self.__generate_trimauto()
        self.__generate_trimin(atomic_numbers, energies)
        self.__generate_trimdat(
            atomic_numbers,
            energies,
            depths=depths,
            ys=ys,
            zs=zs,
            cosxs=cosxs,
            cosys=cosys,
            coszs=coszs,
        )

        # Run SRIM
        print(f"Running {len(atomic_numbers)} SRIM ions")
        try:
            window_thread = threading.Thread(target=self.__minimize_and_handle_popup)
            window_thread.start()
            curr_dir = os.getcwd()
            os.chdir(self.srim_dir)
            subprocess.check_call([Path("./TRIM.exe")])
            os.chdir(curr_dir)
            window_thread.join()
        except subprocess.CalledProcessError as e:
            print(traceback.format_exc())
            print(f"An error occurred while running the subprocess: {e}")

        # Append output files
        srimdb.append_output()
        srimdb.commit()
        if fail_on_transmit:
            self.__check_transmit(srimdb)
        if fail_on_backscat:
            self.__check_backscat(srimdb)
        srimdb.optimize()

    def __collect_recoils(
        self,
        max_recoil_energy: float,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        depths: npt.NDArray[np.float64],
        ys: npt.NDArray[np.float64],
        zs: npt.NDArray[np.float64],
        cosxs: npt.NDArray[np.float64],
        cosys: npt.NDArray[np.float64],
        coszs: npt.NDArray[np.float64],
    ) -> None:
        """Collect all recoils from all SRIM databases into a single database taking into account
        their hierarchy.

        This is the Py2SRIM version of the SPECTRA-PKA → SRIM collector.

        Differences vs the original:
        - It does not read SPECTRA-PKA files.
        - `event` is the ion index provided to `Py2SRIM.run`, 1-based (i + 1).
        - It assumes `self.root_dir` already contains the SRIM tree created by `run`.
        - It assumes the same `max_recoil_energy` used to build the SRIM tree.

        Parameters
        ----------
        max_recoil_energy : float
            Recoils above this energies will be sent to SRIM, in eV.
        atomic_numbers : npt.NDArray[np.int64]
            Ion atomic numbers.
        energies : npt.NDArray[np.float64]
            Ion energies.
        depths : npt.NDArray[np.float64]
            Ion initial depths.
        ys : npt.NDArray[np.float64]
            Ion initial y positions.
        zs : npt.NDArray[np.float64]
            Ion initial z positions.
        cosxs : npt.NDArray[np.float64]
            Ion initial x directions.
        cosys : npt.NDArray[np.float64]
            Ion initial y directions.
        coszs : npt.NDArray[np.float64]
            Ion initial z directions.
        """
        # For each SRIM database, keep track of how many ions we have already consumed.
        # Key is the full path to the srim.db file.
        srim_ion_counters: dict[Path, int] = defaultdict(int)

        def collect_recoils_from_srim(
            tree: tuple[int, ...],
            ion_numb: int,
            event: int,
        ) -> None:
            """Collect recoils from a single SRIM ion and recurse on high-energy recoils.

            Parameters
            ----------
            tree : tuple[int, ...]
                Sequence of atomic numbers describing the SRIM path, e.g. (26,), (26, 76), ...
                The corresponding SRIM DB is at:
                    root_dir / '26' / '76' / ... / 'srim.db'
            ion_numb : int
                Ion number inside this SRIM DB (ion_numb column).
            event : int
                Event index, 1-based. Here it is the original ion index + 1 from Py2SRIM.run.
            """
            # Path to current SRIM DB for this tree
            branch_path = self.__tree2path_db(tree, create_parent_dir=False)

            # If this SRIM DB does not exist (e.g., max_srim_iters prevented creation), stop here.
            if not branch_path.exists():
                return

            srimdb_branch = self.__create_srimdb(
                path=branch_path,
                target=None,
                calculation=None,
            )
            collisions = list(
                srimdb_branch.read(
                    table="collision",
                    what="depth, y, z, cosx, cosy, cosz, recoil_energy, atom_hit",
                    conditions=f"WHERE ion_numb={ion_numb}",
                )
            )
            srimdb_branch.close()

            for (
                depth,
                y,
                z,
                cosx,
                cosy,
                cosz,
                recoil_energy,
                atom_hit,
            ) in collisions:
                atomic_number = int(materials.ATOMIC_NUMBER_BY_SYMBOL[atom_hit])

                if recoil_energy < max_recoil_energy:
                    # This recoil is below threshold -> terminal; store it.
                    self.recoilsdb.insert_recoil(
                        event=event,
                        atomic_number=atomic_number,
                        recoil_energy=recoil_energy,
                        x=depth,
                        y=y,
                        z=z,
                        cosx=cosx,
                        cosy=cosy,
                        cosz=cosz,
                    )
                    continue

                # Above threshold: try to follow to the next SRIM level.
                leaf_tree = (*tree, atomic_number)
                leaf_db_path = self.__tree2path_db(
                    leaf_tree,
                    create_parent_dir=False,
                )

                # If the child SRIM DB does not exist (e.g., limited by max_srim_iters),
                # treat as terminal.
                if not leaf_db_path.exists():
                    self.recoilsdb.insert_recoil(
                        event=event,
                        atomic_number=atomic_number,
                        recoil_energy=recoil_energy,
                        x=depth,
                        y=y,
                        z=z,
                        cosx=cosx,
                        cosy=cosy,
                        cosz=cosz,
                    )
                    continue

                # Map this collision to the correct ion in the child SRIM DB.
                child_ion_numb = srim_ion_counters[leaf_db_path] + 1
                srim_ion_counters[leaf_db_path] = child_ion_numb
                collect_recoils_from_srim(
                    tree=leaf_tree,
                    ion_numb=child_ion_numb,
                    event=event,
                )

        # Start from the primary ions given to Py2SRIM.run
        nions = atomic_numbers.size

        for i in range(nions):
            event = int(i + 1)
            ion_atomic_number = int(atomic_numbers[i])
            ion_energy = float(energies[i])
            depth = float(depths[i])
            y = float(ys[i])
            z = float(zs[i])
            cosx = float(cosxs[i])
            cosy = float(cosys[i])
            cosz = float(coszs[i])

            # Low-energy primary ion -> store into final DB as terminal recoil.
            if ion_energy < max_recoil_energy:
                self.recoilsdb.insert_recoil(
                    event=event,
                    atomic_number=ion_atomic_number,
                    recoil_energy=ion_energy,
                    x=depth,
                    y=y,
                    z=z,
                    cosx=cosx,
                    cosy=cosy,
                    cosz=cosz,
                )
                continue

            # High-energy primary ion: follow SRIM cascades starting at atomic_number/srim.db.
            branch_path = self.__tree2path_db(
                (ion_atomic_number,),
                create_parent_dir=False,
            )

            # No SRIM data for this ion: treat as terminal.
            # Likely due to max_srim_iters or an aborted run.
            if not branch_path.exists():
                self.recoilsdb.insert_recoil(
                    event=event,
                    atomic_number=ion_atomic_number,
                    recoil_energy=ion_energy,
                    x=depth,
                    y=y,
                    z=z,
                    cosx=cosx,
                    cosy=cosy,
                    cosz=cosz,
                )
                continue

            # Ion index in this first-level SRIM DB.
            ion_numb = srim_ion_counters[branch_path] + 1
            srim_ion_counters[branch_path] = ion_numb

            collect_recoils_from_srim(
                tree=(ion_atomic_number,),
                ion_numb=ion_numb,
                event=event,
            )

    def __collect_ions_vacs(
        self,
        max_recoil_energy: float,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
    ) -> None:
        """Collect all ions and vacancies from all SRIM databases into a single database
        taking into account their hierarchy.

        This is the Py2SRIM version of the SPECTRA-PKA → SRIM ions/vacs collector.

        Differences vs the original Spectra2SRIM implementation:
        - It does not read SPECTRA-PKA files.
        - `event` is the ion index provided to `Py2SRIM.run`, 1-based (i + 1).
        - It assumes `self.root_dir` already contains the SRIM tree created by `run`.
        - It assumes the same `max_recoil_energy` used to build the SRIM tree.
        - No depth offset is applied (no mid-target injection as in Spectra2SRIM).
        """
        # For each SRIM database, keep track of how many ions we have already consumed.
        # Key is the full path to the srim.db file.
        srim_ion_counters: dict[Path, int] = defaultdict(int)

        def collect_ions_vacs_from_srim(
            tree: tuple[int, ...],
            ion_numb: int,
            event: int,
        ) -> None:
            """Collect ions and vacancies from a single SRIM ion and recurse on high-energy
            recoils.

            Parameters
            ----------
            tree : tuple[int, ...]
                Sequence of atomic numbers describing the SRIM path, e.g. (26,), (26, 76), ...
                The corresponding SRIM DB is at:
                    root_dir / '26' / '76' / ... / 'srim.db'
            ion_numb : int
                Ion number inside this SRIM DB (ion_numb column).
            event : int
                Event index, 1-based (ion index from Py2SRIM.run).
            """
            # Path to current SRIM DB for this tree
            branch_path = self.__tree2path_db(tree, create_parent_dir=False)

            # If this SRIM DB does not exist (e.g., max_srim_iters prevented creation), stop.
            if not branch_path.exists():
                return

            srimdb_branch = self.__create_srimdb(
                path=branch_path,
                target=None,
                calculation=None,
            )

            # Initial ion positions and atomic number for this ion_numb
            trimdat_rows = list(
                srimdb_branch.read(
                    table="trimdat",
                    what="depth, y, z, atom_numb",
                    conditions=f"WHERE ion_numb={ion_numb}",
                )
            )
            # Final ion positions (vacancies) for this ion_numb
            range3d_rows = list(
                srimdb_branch.read(
                    table="range3d",
                    what="depth, y, z",
                    conditions=f"WHERE ion_numb={ion_numb}",
                )
            )
            # Recoils for this ion_numb to decide further SRIM levels
            collision_rows = list(
                srimdb_branch.read(
                    table="collision",
                    what="recoil_energy, atom_hit",
                    conditions=f"WHERE ion_numb={ion_numb}",
                )
            )
            srimdb_branch.close()

            # Ions: atom_numb != 0, from TRIMDAT initial positions
            for depth, y, z, atom_numb in trimdat_rows:
                self.recoilsdb.insert_ion_vac(
                    event=event,
                    atom_numb=int(atom_numb),
                    x=depth,
                    y=y,
                    z=z,
                )

            # Vacancies: atom_numb = 0, from RANGE_3D final positions
            for depth, y, z in range3d_rows:
                self.recoilsdb.insert_ion_vac(
                    event=event,
                    atom_numb=0,
                    x=depth,
                    y=y,
                    z=z,
                )

            # Recurse on high-energy recoils
            for recoil_energy, atom_hit in collision_rows:
                recoil_energy = float(recoil_energy)
                atomic_number = int(materials.ATOMIC_NUMBER_BY_SYMBOL[atom_hit])

                if recoil_energy < max_recoil_energy:
                    # Below threshold -> terminal for ions/vacs purposes
                    continue

                leaf_tree = (*tree, atomic_number)
                leaf_db_path = self.__tree2path_db(
                    leaf_tree,
                    create_parent_dir=False,
                )

                # If the child SRIM DB does not exist (e.g., limited by max_srim_iters),
                # treat as terminal.
                if not leaf_db_path.exists():
                    continue

                # Map this recoil to the correct ion in the child SRIM DB.
                child_ion_numb = srim_ion_counters[leaf_db_path] + 1
                srim_ion_counters[leaf_db_path] = child_ion_numb
                collect_ions_vacs_from_srim(
                    tree=leaf_tree,
                    ion_numb=child_ion_numb,
                    event=event,
                )

        # Start from the primary ions given to Py2SRIM.run
        nions = atomic_numbers.size

        for i in range(nions):
            event = int(i + 1)
            ion_atomic_number = int(atomic_numbers[i])
            ion_energy = energies[i]

            # If this primary ion is below the threshold, it was never transferred
            # to any SRIM branch (by construction of the SRIM tree),
            # so there are no ions/vacs to collect for it.
            if ion_energy < max_recoil_energy:
                continue

            # High-energy primary ion: follow SRIM cascades starting at Z/srim.db.
            branch_path = self.__tree2path_db(
                tree=(ion_atomic_number,),
                create_parent_dir=False,
            )

            # No SRIM data for this ion: treat as terminal.
            # Likely due to max_srim_iters or aborted runs.
            if not branch_path.exists():
                continue

            # Ion index in this first-level SRIM DB.
            ion_numb = srim_ion_counters[branch_path] + 1
            srim_ion_counters[branch_path] = ion_numb

            collect_ions_vacs_from_srim(
                tree=(ion_atomic_number,),
                ion_numb=ion_numb,
                event=event,
            )

    def run(
        self,
        root_dir: Path,
        target: list[Component],
        calculation: str,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        depths: npt.NDArray[np.float64],
        ys: npt.NDArray[np.float64],
        zs: npt.NDArray[np.float64],
        cosxs: npt.NDArray[np.float64],
        cosys: npt.NDArray[np.float64],
        coszs: npt.NDArray[np.float64],
        max_recoil_energy: float,
        max_srim_iters: int,
        fail_on_transmit: bool,
        fail_on_backscatt: bool,
        ignore_32bit_warning: bool = True,
    ) -> RecoilsDB:
        """Run SRIM iteratively, creating a folder tree driven by a recoil-energy threshold.

        - group ions by atomic number, keeping only those with energy > ``max_recoil_energy``
        - create a directory tree under ``root_dir`` of the form:
              root_dir / atomic_number_1 / [atomic_number_2 / atomic_number_3 / ...]
          where each branch holds a ``srim.db`` file
        - run SRIM once per branch
        - recursively spawn new SRIM runs for recoils from the ``collision`` table whose
          energy is above ``max_recoil_energy``
        - stop at depth ``max_srim_iters`` (depth is len(tree), e.g. (26, 76, 26) -> 3)

        Parameters
        ----------
        root_dir: Path
            Root directory where all calculations will be stored.
        srim_target : SRIMTarget
            SRIM target.
        calculation : str
            SRIM calculation.
        atomic_numbers : npt.NDArray[np.int64]
            Ion atomic numbers.
        energies : npt.NDArray[np.float64]
            Ion energies.
        depths : npt.NDArray[np.float64]
            Ion initial depths.
        ys : npt.NDArray[np.float64]
            Ion initial y positions.
        zs : npt.NDArray[np.float64]
            Ion initial z positions.
        cosxs : npt.NDArray[np.float64]
            Ion initial x directions.
        cosys : npt.NDArray[np.float64]
            Ion initial y directions.
        coszs : npt.NDArray[np.float64]
            Ion initial z directions.
        max_recoil_energy : float
            Recoils above this energy (eV) will spawn further SRIM branches.
        max_srim_iters : int
            Maximum number of SRIM iterations.
        fail_on_transmit : bool
            If True, raise if any ion is transmitted (TRANSMIT.txt non-empty).
        fail_on_backscatt : bool
            If True, raise if any ion is backscattered (BACKSCAT.txt non-empty).
        ignore_32bit_warning : bool (default=True)
            Whether to ignore the 32-bit warning when using 32-bit SRIM with 64-bit Python.

        Returns
        -------
        RecoilsDB
            Database with all recoils collected.
        """
        self.root_dir = root_dir
        self.target = target
        self.calculation = calculation
        if max_srim_iters < 1:
            raise ValueError("max_srim_iters must be at least 1")
        if self.calculation not in {"quick", "full", "mono"}:
            raise ValueError("calculation must be 'quick', 'full' or 'mono'")

        self.root_dir.mkdir(parents=True, exist_ok=True)
        self.recoilsdb = RecoilsDB(self.root_dir / "recoils.db")

        def run_branch(
            tree: tuple[int, ...],
            batch: dict[str, npt.NDArray[np.float64]],
        ) -> None:
            """Run SRIM for one branch in the tree and write root_dir/.../srim.db."""
            path = self.__tree2path_db(tree, True)
            srimdb = self.__create_srimdb(
                path=path,
                target=self.target,
                calculation=self.calculation,
            )
            self.__run(
                srimdb=srimdb,
                atomic_numbers=batch["atomic_numbers"],
                energies=batch["energies"],
                depths=batch["depths"],
                ys=batch["ys"],
                zs=batch["zs"],
                cosxs=batch["cosxs"],
                cosys=batch["cosys"],
                coszs=batch["coszs"],
                fail_on_backscat=fail_on_backscatt,
                fail_on_transmit=fail_on_transmit,
                ignore_32bit_warning=ignore_32bit_warning,
            )
            srimdb.close()

        def recurse(tree: tuple[int, ...]) -> None:
            """Process one srim.db and recursively spawn branches."""
            path = self.__tree2path_db(tree, False)
            # Database not existing: no recoils to process
            if not path.exists():
                return

            # Collect recoils from this branch for the next iteration
            srimdb_branch = self.__create_srimdb(
                path=path,
                target=None,
                calculation=None,
            )
            collisions = list(
                srimdb_branch.read(
                    table="collision",
                    what="depth, y, z, cosx, cosy, cosz, recoil_energy, atom_hit",
                    conditions="ORDER BY ion_numb",
                )
            )
            srimdb_branch.close()
            if not collisions:
                return

            branch_depths = np.array([row[0] for row in collisions], dtype=np.float64)
            branch_ys = np.array([row[1] for row in collisions], dtype=np.float64)
            branch_zs = np.array([row[2] for row in collisions], dtype=np.float64)
            branch_cosxs = np.array([row[3] for row in collisions], dtype=np.float64)
            branch_cosys = np.array([row[4] for row in collisions], dtype=np.float64)
            branch_coszs = np.array([row[5] for row in collisions], dtype=np.float64)
            branch_energies = np.array([row[6] for row in collisions], dtype=np.float64)
            branch_atomic_numbers = np.array(
                [materials.ATOMIC_NUMBER_BY_SYMBOL[row[7]] for row in collisions],
                dtype=np.int32,
            )
            leaf_batches = self.__separate_ions_by_atomic_number(
                energy_threshold=max_recoil_energy,
                atomic_numbers=branch_atomic_numbers,
                energies=branch_energies,
                depths=branch_depths,
                ys=branch_ys,
                zs=branch_zs,
                cosxs=branch_cosxs,
                cosys=branch_cosys,
                coszs=branch_coszs,
            )
            # No recoils above threshold
            if not leaf_batches:
                return

            for atomic_number, batch in leaf_batches.items():
                leaf_tree = (*tree, int(atomic_number))
                depth_iter = len(leaf_tree)
                if depth_iter >= max_srim_iters:
                    tree_str = "/".join(str(z) for z in leaf_tree)
                    print(
                        f"Skipping SRIM for Z={atomic_number} (path {tree_str}): "
                        f"reached max_srim_iters={max_srim_iters}"
                    )
                    continue

                run_branch(leaf_tree, batch)
                recurse(leaf_tree)

        batches = self.__separate_ions_by_atomic_number(
            energy_threshold=max_recoil_energy,
            atomic_numbers=atomic_numbers,
            energies=energies,
            depths=depths,
            ys=ys,
            zs=zs,
            cosxs=cosxs,
            cosys=cosys,
            coszs=coszs,
        )
        if not batches:
            print("No ions above the recoil energy threshold; nothing to run.")
            return

        for atomic_number, batch in batches.items():
            tree = (int(atomic_number),)
            run_branch(tree, batch)
            if max_srim_iters > 1:
                recurse(tree)

        # Collect all recoils data into a single database
        self.__collect_recoils(
            max_recoil_energy=max_recoil_energy,
            atomic_numbers=atomic_numbers,
            energies=energies,
            depths=depths,
            ys=ys,
            zs=zs,
            cosxs=cosxs,
            cosys=cosys,
            coszs=coszs,
        )
        # Collect all ions and vacancies into a single database
        self.__collect_ions_vacs(
            max_recoil_energy=max_recoil_energy,
            atomic_numbers=atomic_numbers,
            energies=energies,
        )
        self.recoilsdb.save_target(self.target)
        self.recoilsdb.commit()

        return self.recoilsdb

    # endregion
