"""This module contains the `Py2SRIM` class."""

import os
import platform
import sqlite3
import subprocess
import threading
import time
import traceback
import warnings
from dataclasses import dataclass, field
from pathlib import Path

import numpy as np
from numpy import typing as npt

from irradiapy import config, dtypes, materials
from irradiapy.srim.srimdb import SRIMDB
from irradiapy.srim.target.target import Target

platform = platform.system()
if platform == "Windows":
    import pygetwindow
    import pywinauto
else:
    warnings.warn(
        "SRIM subpackage only works for Windows. " f"'{platform}' not supported."
    )


@dataclass
class Py2SRIM:
    """Base class for running SRIM calculations from Python.

    Attributes
    ----------
    dir_root: Path
        Root directory where all calculations will be stored.
    target : Target
        SRIM target.
    calculation : str
        SRIM calculation.
    seed : int (default=0)
        Seed for SRIM randomness.
    dir_srim : Path (default=config.DIR_SRIM)
        Directory where SRIM is installed.
    check_interval : float (default=0.2)
        Interval to check for SRIM window/popups.
    plot_type : int (default=5)
        Plot type during SRIM calculations. 5 for no plots (faster calculations).
    xmin : float (default=0.0)
        Minimum x for plots and depth-dependent means during SRIM calculations. Particularly
        important for large targets, since SRIM divides it in 100 segments.
    xmax : float (default=0.0)
        Maximum x for plots and depth-dependent means during SRIM calculations. Particularly
        important for large targets, since SRIM divides it in 100 segments.
        0.0 for full target.
    do_ranges : int (default=1)
        Whether to save `RANGE.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_backscatt : int (default=1)
        Whether to save `BACKSCAT.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_transmit : int (default=1)
        Whether to save `TRANSMIT.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_sputtered : int (default=1)
        Whether to save `SPUTTER.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    do_collisions : int (default=1)
        Whether to save `COLLISON.txt` file.
        Disabling this might cause errors afterwards because of missing tables.
    exyz : float (default=0.0)
        Whether to save ions position every time they loose `exyz` energy in the `EXYZ.txt` file.
    autosave : int (default=0)
        Autosave every this number of ions. 0 to disable.
    """

    seed: int = 0

    dir_root: Path = field(init=False)
    target: Target = field(init=False)
    calculation: str = field(init=False)
    dir_srim: Path = field(default_factory=lambda: config.DIR_SRIM)

    check_interval: float = 0.2
    plot_type: int = 5
    xmin: float = 0.0
    xmax: float = 0.0
    do_ranges: int = 1
    do_backscatt: int = 1
    do_transmit: int = 1
    do_sputtered: int = 1
    do_collisions: int = 1
    exyz: float = 0.0
    autosave: int = 0

    reminders: int = field(default=0, init=False)
    bragg: int = field(default=1, init=False)

    # region SRIM files

    def __generate_trimin(
        self,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        target: Target,
    ) -> None:
        """Generates `TRIM.IN` file."""
        nions = len(atomic_numbers)
        atomic_mass = materials.MATERIALS_BY_ATOMIC_NUMBER[
            atomic_numbers[0]
        ].mass_number
        energy = np.ceil(energies.max()) / 1e3
        if self.calculation == "quick":
            calculation = 4
        elif self.calculation == "full":
            calculation = 5
        else:
            calculation = 7
        trimin_path = self.dir_srim / "TRIM.IN"
        with open(trimin_path, "w", encoding="utf-8") as file:
            file.write("TRIM.IN file generated by irradiapy.\n")
            file.write(
                (
                    "ion Z, A, energy, angle, number of ions, Bragg correction, autosave\n"
                    f"{atomic_numbers[0]} {atomic_mass} {energy} 0 "
                    f"{nions} {self.bragg} {self.autosave}\n"
                )
            )
            file.write(
                (
                    "calculation, seed, reminders\n"
                    f"{calculation} {self.seed} {self.reminders}\n"
                )
            )
            file.write(
                (
                    "Diskfiles (0=no,1=yes): Ranges, Backscatt, Transmit, Sputtered, "
                    "Collisions(1=Ion;2=Ion+Recoils), Special EXYZ.txt file\n"
                    f"{self.do_ranges} {self.do_backscatt} {self.do_transmit} {self.do_sputtered} "
                    f"{self.do_collisions} {self.exyz}\n"
                )
            )
            file.write(target.trimin_description() + "\n")
            file.write(
                (
                    "PlotType (0-5); Plot Depths: Xmin, Xmax(Ang.) [=0 0 for Viewing Full Target]\n"
                    f"{self.plot_type} {self.xmin} {self.xmax}\n"
                )
            )
            file.write(target.trimin_target_elements())
            file.write(target.trimin_target_layers() + "\n")
            file.write(target.trimin_phases() + "\n")
            file.write(target.trimin_bragg() + "\n")
            file.write(target.trimin_displacement() + "\n")
            file.write(target.trimin_lattice() + "\n")
            file.write(target.trimin_surface() + "\n")
            file.write("Stopping Power Version\n0\n")

    def __generate_trimdat(
        self,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        depths: None | npt.NDArray[np.float64] = None,
        ys: None | npt.NDArray[np.float64] = None,
        zs: None | npt.NDArray[np.float64] = None,
        cosxs: None | npt.NDArray[np.float64] = None,
        cosys: None | npt.NDArray[np.float64] = None,
        coszs: None | npt.NDArray[np.float64] = None,
    ) -> npt.NDArray[np.float64]:
        """Generates `TRIM.DAT` file.

        Parameters
        ----------
        atomic_numbers : npt.NDArray[np.int64]
            Atomic numbers.
        energies : npt.NDArray[np.float64]
            Energies.
        depths : npt.NDArray[np.float64] | None  (default=None)
            Depths.
        ys : npt.NDArray[np.float64] | None (default=None)
            Y positions.
        zs : npt.NDArray[np.float64] | None (default=None)
            Z positions.
        cosxs : npt.NDArray[np.float64] | None (default=None)
            X directions.
        cosys : npt.NDArray[np.float64] | None (default=None)
            Y directions.
        coszs : npt.NDArray[np.float64] | None (default=None)
            Z directions.

        Returns
        -------
        npt.NDArray[np.float64]
            `TRIM.DAT` data.
        """
        trimdat_path = self.dir_srim / "TRIM.DAT"
        nions = atomic_numbers.size
        if depths is None:
            depths = np.zeros(nions)
        if ys is None:
            ys = np.zeros(nions)
        if zs is None:
            zs = np.zeros(nions)
        if cosxs is None:
            cosxs = np.ones(nions)
        if cosys is None:
            cosys = np.zeros(nions)
        if coszs is None:
            coszs = np.zeros(nions)
        names = np.array([f"{i:06d}" for i in range(1, nions + 1)], dtype=str)
        with open(trimdat_path, "w", encoding="utf-8") as file:
            file.write("<TRIM>\n" * 9)
            file.write("Name atomic_number E x y z cosx cosy cosz\n")
            for i in range(nions):
                file.write(
                    (
                        f"{names[i]} {atomic_numbers[i]} {energies[i]} {depths[i]} {ys[i]} "
                        f"{zs[i]} {cosxs[i]} {cosys[i]} {coszs[i]}\n"
                    )
                )
        data = np.empty(nions, dtype=dtypes.trimdat)
        for i in range(nions):
            data[i]["name"] = names[i]
            data[i]["atomic_number"] = atomic_numbers[i]
            data[i]["energy"] = energies[i]
            data[i]["pos"] = np.array([depths[i], ys[i], zs[i]])
            data[i]["dir"] = np.array([cosxs[i], cosys[i], coszs[i]])
        return data

    def __generate_trimauto(self) -> None:
        """Generates `TRIMAUTO` file."""
        with open(self.dir_srim / "TRIMAUTO", "w", encoding="utf-8") as file:
            file.write("1\n\nCheck TRIMAUTO.txt for details.\n")

    # endregion

    # region Recoils direction

    @staticmethod
    def __get_dir(
        pos0: npt.NDArray[np.float64],
        pos: npt.NDArray[np.float64],
    ) -> npt.NDArray[np.float64]:
        """Gets the direction from two positions.

        Parameters
        pos0 : npt.NDArray[np.float64]
            Initial position.
        pos : npt.NDArray[np.float64]
            Final position.
        """
        diff = pos - pos0
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore",
                category=RuntimeWarning,
                message="invalid value encountered in divide",
            )
            direction = diff / np.linalg.norm(diff)
        return direction

    @staticmethod
    def __add_recoils_dirs(srimdb: SRIMDB, trimdat: dtypes.Trimdat) -> tuple:
        """Add recoil directions to collision table.

        Parameters
        ----------
        trimdat : dtypes.Trimdat
            TRIMDAT data.
        """
        cur = srimdb.collision.cursor()
        cur.execute("ALTER TABLE collision ADD COLUMN cosx REAL")
        cur.execute("ALTER TABLE collision ADD COLUMN cosy REAL")
        cur.execute("ALTER TABLE collision ADD COLUMN cosz REAL")

        nions = srimdb.get_nions()
        for nion in range(nions):
            pos0 = trimdat[nion]["pos"]
            cosx0, cosy0, cosz0 = trimdat[nion]["dir"]
            for collision in srimdb.collision.read(what="rowid, depth, y, z"):
                rowid, depth, y, z = collision
                pos = np.array([depth, y, z])
                cosx, cosy, cosz = Py2SRIM.__get_dir(pos0, pos)
                # There are some rare cases, specially at high energies,
                # when there are two PKA at the same position. I think this
                # is because they are really close and when saved into
                # COLLISON.txt, positions are rounded and they coincide.
                # In such cases (if statement triggered), we assume that the
                # second PKA has the same direction as the first one.
                if np.isnan(cosx) or np.isnan(cosy) or np.isnan(cosz):
                    warnings.warn(
                        (
                            "Two PKAs at the same position, assuming same direction. This is "
                            "likely because of SRIM rounding positions when saving into "
                            "COLLISON.txt."
                        ),
                        RuntimeWarning,
                    )
                    cosx, cosy, cosz = cosx0, cosy0, cosz0
                else:
                    cosx0, cosy0, cosz0 = cosx, cosy, cosz
                cur.execute(
                    "UPDATE collision SET cosx = ?, cosy = ?, cosz = ? WHERE rowid = ?",
                    (
                        cosx,
                        cosy,
                        cosz,
                        rowid,
                    ),
                )
                pos0 = pos
        cur.close()

    # endregion

    # region Offsets

    @staticmethod
    def __remove_mean_depth_offsets(
        cur: sqlite3.Cursor, table_name: str, depth_mean: tuple[float]
    ) -> None:
        """Removes ion mean depth offsets from the given table.

        Parameters
        ----------
        cur : sqlite3.Cursor
            Database cursor.
        table_name : str
            Table name.
        depth_mean : tuple[float]
            Mean depth.
        """
        cur.execute(f"UPDATE {table_name} SET depth = depth - ?", depth_mean)

    @staticmethod
    def __remove_individual_offsets(cur: sqlite3.Cursor, table_name: str) -> None:
        """Removes individual ion offsets from the given table.

        Parameters
        ----------
        cur : sqlite3.Cursor
            Database cursor.
        table_name : str
            Table name.
        """
        cur.execute(
            f"""
            UPDATE {table_name}
            SET depth = {table_name}.depth - trimdat.depth,
                y = {table_name}.y - trimdat.y,
                z = {table_name}.z - trimdat.z
            FROM trimdat
            WHERE {table_name}.ion_numb = trimdat.ion_numb
        """
        )

    def __remove_offsets(self, srimdb: SRIMDB) -> None:
        """Removes ion offsets."""
        cur = srimdb.cursor()
        cur.execute("SELECT AVG(depth) FROM trimdat")
        depth_mean = cur.fetchone()
        self.__remove_mean_depth_offsets(cur, "e2recoil", depth_mean)
        self.__remove_mean_depth_offsets(cur, "ioniz", depth_mean)
        self.__remove_mean_depth_offsets(cur, "lateral", depth_mean)
        self.__remove_mean_depth_offsets(cur, "phonon", depth_mean)
        self.__remove_mean_depth_offsets(cur, "range", depth_mean)
        self.__remove_mean_depth_offsets(cur, "vacancy", depth_mean)
        if self.calculation in ["full", "mono"]:
            self.__remove_mean_depth_offsets(cur, "novac", depth_mean)
        self.__remove_individual_offsets(cur, "backscat")
        self.__remove_individual_offsets(cur, "collision")
        self.__remove_individual_offsets(cur, "range3d")
        self.__remove_individual_offsets(cur, "sputter")
        self.__remove_individual_offsets(cur, "transmit")
        self.__remove_individual_offsets(cur, "transmit")
        cur.close()
        srimdb.commit()

    # endregion

    # region Checks

    def __check_transmit(self, srimdb: SRIMDB) -> None:
        """Checks if there are transmitted ions in the database."""
        transmit_rows = list(srimdb.transmit.read())
        if transmit_rows:
            msg = ", ".join(f"({row[1]}, {row[2]:.2g})" for row in transmit_rows)
            raise RuntimeError(
                "SRIM ions ended up transmitted. Consider increasing the "
                "effective target width. (Z, E (eV)) = " + msg
            )

    def __check_backscat(self, srimdb: SRIMDB) -> None:
        """Checks if there are backscattered ions in the database."""
        backscat_rows = list(srimdb.backscat.read())
        if backscat_rows:
            msg = ", ".join(f"({row[1]}, {row[2]:.2g})" for row in backscat_rows)
            raise RuntimeError(
                "SRIM ions ended up backscattered. Consider increasing the "
                "effective target width. (Z, E (eV)) = " + msg
            )

    # endregion

    # region Run

    def __create_srimdb(
        self,
        path_db: Path,
        target: Target,
        calculation: str,
    ) -> SRIMDB:
        """Creates a SRIMDB instance."""
        srimdb = SRIMDB(
            path_db=path_db,
            target=target,
            calculation=calculation,
            seed=self.seed,
            plot_type=self.plot_type,
            xmin=self.xmin,
            xmax=self.xmax,
            do_ranges=self.do_ranges,
            do_backscatt=self.do_backscatt,
            do_transmit=self.do_transmit,
            do_sputtered=self.do_sputtered,
            do_collisions=self.do_collisions,
            exyz=self.exyz,
            autosave=self.autosave,
        )
        return srimdb

    def __minimize_and_handle_popup(self):
        """Minimizes the SRIM window and handles the end of calculation popup."""
        # pylint: disable=protected-access
        window_title = "SRIM-2013.00"
        popup_title = "End of TRIM.DAT calculation"
        if platform == "Windows":
            # Minimize window
            while True:
                windows = pygetwindow.getWindowsWithTitle(window_title)
                if windows:
                    window = windows[0]
                    app = pywinauto.Application().connect(handle=window._hWnd)
                    app.window(handle=window._hWnd).minimize()
                    break
                time.sleep(self.check_interval)
            # Dismiss popup (quick-calculation does not have this popup)
            if self.calculation != "quick":
                while True:
                    popups = pygetwindow.getWindowsWithTitle(popup_title)
                    if popups:
                        popup = popups[0]
                        app = pywinauto.Application().connect(handle=popup._hWnd)
                        app.window(handle=popup._hWnd).send_keystrokes("{ENTER}")
                        break
                    time.sleep(self.check_interval)
        elif platform == "Linux":
            # Minimize window
            while True:
                windows = pygetwindow.getWindowsWithTitle(window_title)
                if windows:
                    window = windows[0]
                    window_id = window._hWnd  # pylint: disable=protected-access
                    subprocess.run(
                        ["xdotool", "windowminimize", str(window_id)], check=True
                    )
                    break
                time.sleep(self.check_interval)
            # Dismiss popup (quick-calculation does not have this popup)
            if self.calculation != "quick":
                while True:
                    popups = pygetwindow.getWindowsWithTitle(popup_title)
                    if popups:
                        popup = popups[0]
                        popup_id = popup._hWnd  # pylint: disable=protected-access
                        subprocess.run(
                            ["xdotool", "windowactivate", str(popup_id)], check=True
                        )
                        subprocess.run(["xdotool", "key", "Return"], check=True)
                        break
                    time.sleep(self.check_interval)

    @staticmethod
    def __separate_ions_by_atomic_number(
        energy_threshold: float,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        **extra_fields: npt.NDArray[np.float64],
    ) -> dict[int, dict[str, npt.NDArray[np.float64]]]:
        """Group ions by atomic number, keeping only those above the energy threshold.

        Parameters
        ----------
        energy_threshold : float
            Minimum energy (eV) to include an ion in the output.
        atomic_numbers : array_like
            Atomic number of each ion.
        energies : array_like
            Energy (eV) of each ion. Used for thresholding.
        **extra_fields : array_like
            Any extra per-ion arrays to propagate (depths, ys, zs, cosxs, ...).

        Returns
        -------
        dict[int, dict[str, np.ndarray]]
            A dictionary keyed by atomic number. Each value is another dict with:
                'atomic_numbers' : np.ndarray
                'energies'       : np.ndarray
                '<field name>'   : np.ndarray  # for each entry in extra_fields
                'nions'          : int
        """
        if energies.shape != atomic_numbers.shape:
            raise ValueError(
                "`energies` and `atomic_numbers` must have the same shape."
            )

        ions: dict[int, dict[str, npt.NDArray[np.float64]]] = {}
        unique_atomic_numbers = np.unique(atomic_numbers)

        for atomic_number in unique_atomic_numbers:
            mask = (atomic_numbers == atomic_number) & (energies > energy_threshold)
            if not np.any(mask):
                continue

            batch: dict[str, npt.NDArray[np.float64]] = {
                "atomic_numbers": atomic_numbers[mask],
                "energies": energies[mask],
            }
            for name, arr in extra_fields.items():
                batch[name] = arr[mask]
            batch["nions"] = batch["atomic_numbers"].size

            ions[int(atomic_number)] = batch

        return ions

    def __tree2path_db(
        self,
        tree: tuple[int, ...],
        create_parent_dir: bool,
    ) -> Path:
        """Converts a tree tuple into a database path.

        Parameters
        ----------
        tree : tuple[int, ...]
            Tree tuple.
        create_parent_dir : bool
            Whether to create the parent directory.

        Returns
        -------
        Path
            Database path.
        """
        dir_branch = self.dir_root.joinpath(
            *(str(atomic_number) for atomic_number in tree)
        )
        if create_parent_dir:
            dir_branch.mkdir(parents=True, exist_ok=True)
        path_db = dir_branch / "srim.db"
        return path_db

    def __run(
        self,
        srimdb: SRIMDB,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        depths: npt.NDArray[np.float64] | None,
        ys: npt.NDArray[np.float64] | None,
        zs: npt.NDArray[np.float64] | None,
        cosxs: npt.NDArray[np.float64] | None,
        cosys: npt.NDArray[np.float64] | None,
        coszs: npt.NDArray[np.float64] | None,
        fail_on_backscat: bool,
        fail_on_transmit: bool,
        remove_offsets: bool,
        ignore_32bit_warning: bool = True,
    ) -> None:
        """Run the SRIM simulation.

        Parameters
        ----------
        srimdb : SRIMDB
            SRIM database.
        atomic_numbers : npt.NDArray[np.int64]
            Ion atomic numbers.
        energies : npt.NDArray[np.float64]
            Ion energies.
        depths : npt.NDArray[np.float64] | None
            Ion initial depths.
        ys : npt.NDArray[np.float64] | None
            Ion initial y positions.
        zs : npt.NDArray[np.float64] | None
            Ion initial z positions.
        cosxs : npt.NDArray[np.float64] | None
            Ion initial x directions.
        cosys : npt.NDArray[np.float64] | None
            Ion initial y directions.
        coszs : npt.NDArray[np.float64] | None
            Ion initial z directions.
        fail_on_backscat : bool
            Whether to fail if there are backscattered ions.
        fail_on_transmit : bool
            Whether to fail if there are transmitted ions.
        remove_offsets : bool
            Whether to remove initial ion position to have positions relative to ion start.
        """
        if ignore_32bit_warning:
            warnings.filterwarnings(
                "ignore",
                category=UserWarning,
                message="32-bit application should be automated using 32-bit Python",
            )

        if srimdb.table_exists("trimdat"):
            raise RuntimeError(
                (
                    f"The database {srimdb.path_db} is already populated "
                    "with data from another simulation, use another one."
                )
            )

        # Generate input files
        self.__generate_trimauto()
        self.__generate_trimin(atomic_numbers, energies, self.target)
        trimdat = self.__generate_trimdat(
            atomic_numbers,
            energies,
            depths=depths,
            ys=ys,
            zs=zs,
            cosxs=cosxs,
            cosys=cosys,
            coszs=coszs,
        )

        # Run SRIM
        print(f"Running {len(atomic_numbers)} SRIM ions")
        try:
            window_thread = threading.Thread(target=self.__minimize_and_handle_popup)
            window_thread.start()
            curr_dir = os.getcwd()
            os.chdir(self.dir_srim)
            subprocess.check_call([Path("./TRIM.exe")])
            os.chdir(curr_dir)
            window_thread.join()
        except subprocess.CalledProcessError as e:
            print(traceback.format_exc())
            print(f"An error occurred while running the subprocess: {e}")

        # Append output files
        srimdb.append_output()
        self.__add_recoils_dirs(srimdb, trimdat)
        srimdb.commit()
        if fail_on_transmit:
            self.__check_transmit(srimdb)
        if fail_on_backscat:
            self.__check_backscat(srimdb)
        if remove_offsets:
            self.__remove_offsets(srimdb)
        srimdb.optimize()

    def run(
        self,
        dir_root: Path,
        target: Target,
        calculation: str,
        atomic_numbers: npt.NDArray[np.int64],
        energies: npt.NDArray[np.float64],
        depths: npt.NDArray[np.float64],
        ys: npt.NDArray[np.float64],
        zs: npt.NDArray[np.float64],
        cosxs: npt.NDArray[np.float64],
        cosys: npt.NDArray[np.float64],
        coszs: npt.NDArray[np.float64],
        max_recoil_energy: float,
        max_srim_iters: int,
        fail_on_transmit: bool,
        fail_on_backscatt: bool,
        remove_offsets: bool = False,
        ignore_32bit_warning: bool = True,
    ) -> None:
        """Run SRIM iteratively, creating a folder tree driven by a recoil-energy threshold.

        - group ions by atomic number, keeping only those with energy > ``max_recoil_energy``
        - create a directory tree under ``dir_root`` of the form:
              dir_root / atomic_number_1 / [atomic_number_2 / atomic_number_3 / ...]
          where each branch holds a ``srim.db`` file
        - run SRIM once per branch
        - recursively spawn new SRIM runs for recoils from the ``collision`` table whose
          energy is above ``max_recoil_energy``
        - stop at depth ``max_srim_iters`` (depth is len(tree), e.g. (26, 76, 26) -> 3)

        Parameters
        ----------
        dir_root: Path
            Root directory where all calculations will be stored.
        target : Target
            SRIM target.
        calculation : str
            SRIM calculation.
        atomic_numbers : npt.NDArray[np.int64]
            Ion atomic numbers.
        energies : npt.NDArray[np.float64]
            Ion energies.
        depths : npt.NDArray[np.float64]
            Ion initial depths.
        ys : npt.NDArray[np.float64]
            Ion initial y positions.
        zs : npt.NDArray[np.float64]
            Ion initial z positions.
        cosxs : npt.NDArray[np.float64]
            Ion initial x directions.
        cosys : npt.NDArray[np.float64]
            Ion initial y directions.
        coszs : npt.NDArray[np.float64]
            Ion initial z directions.
        max_recoil_energy : float
            Recoils above this energy (eV) will spawn further SRIM branches.
        max_srim_iters : int
            Maximum number of SRIM iterations.
        fail_on_transmit : bool
            If True, raise if any ion is transmitted (TRANSMIT.txt non-empty).
        fail_on_backscatt : bool
            If True, raise if any ion is backscattered (BACKSCAT.txt non-empty).
        remove_offsets : bool (default=False)
            Whether to remove initial ion position to have positions relative to ion start.
        ignore_32bit_warning : bool (default=True)
            Whether to ignore the 32-bit warning when using 32-bit SRIM with 64-bit Python.
        """
        self.dir_root = dir_root
        self.target = target
        self.calculation = calculation
        if max_srim_iters < 1:
            raise ValueError("max_srim_iters must be at least 1")
        if self.calculation not in {"quick", "full", "mono"}:
            raise ValueError("calculation must be 'quick', 'full' or 'mono'")

        self.dir_root.mkdir(parents=True, exist_ok=True)

        def run_branch(
            tree: tuple[int, ...],
            batch: dict[str, npt.NDArray[np.float64]],
        ) -> None:
            """Run SRIM for one branch in the tree and write dir_root/.../srim.db."""
            path_db = self.__tree2path_db(tree, True)
            srimdb = self.__create_srimdb(
                path_db=path_db,
                target=self.target,
                calculation=self.calculation,
            )
            self.__run(
                srimdb=srimdb,
                atomic_numbers=batch["atomic_numbers"],
                energies=batch["energies"],
                depths=batch["depths"],
                ys=batch["ys"],
                zs=batch["zs"],
                cosxs=batch["cosxs"],
                cosys=batch["cosys"],
                coszs=batch["coszs"],
                fail_on_backscat=fail_on_backscatt,
                fail_on_transmit=fail_on_transmit,
                remove_offsets=remove_offsets,
                ignore_32bit_warning=ignore_32bit_warning,
            )
            srimdb.close()

        def recurse(tree: tuple[int, ...]) -> None:
            """Process one srim.db and recursively spawn branches."""
            path_db = self.__tree2path_db(tree, False)
            # Database not existing: no recoils to process
            if not path_db.exists():
                return

            # Collect recoils from this branch for the next iteration
            srimdb_branch = self.__create_srimdb(
                path_db=path_db,
                target=None,
                calculation=None,
            )
            collisions = list(
                srimdb_branch.collision.read(
                    what="depth, y, z, cosx, cosy, cosz, recoil_energy, atom_hit",
                    condition="ORDER BY ion_numb",
                )
            )
            srimdb_branch.close()
            if not collisions:
                return

            branch_depths = np.array([row[0] for row in collisions], dtype=np.float64)
            branch_ys = np.array([row[1] for row in collisions], dtype=np.float64)
            branch_zs = np.array([row[2] for row in collisions], dtype=np.float64)
            branch_cosxs = np.array([row[3] for row in collisions], dtype=np.float64)
            branch_cosys = np.array([row[4] for row in collisions], dtype=np.float64)
            branch_coszs = np.array([row[5] for row in collisions], dtype=np.float64)
            branch_energies = np.array([row[6] for row in collisions], dtype=np.float64)
            branch_atomic_numbers = np.array(
                [materials.ATOMIC_NUMBER_BY_SYMBOL[row[7]] for row in collisions],
                dtype=np.int32,
            )
            leaf_batches = self.__separate_ions_by_atomic_number(
                energy_threshold=max_recoil_energy,
                atomic_numbers=branch_atomic_numbers,
                energies=branch_energies,
                depths=branch_depths,
                ys=branch_ys,
                zs=branch_zs,
                cosxs=branch_cosxs,
                cosys=branch_cosys,
                coszs=branch_coszs,
            )
            # No recoils above threshold
            if not leaf_batches:
                return

            for atomic_number, batch in leaf_batches.items():
                leaf_tree = (*tree, int(atomic_number))
                depth_iter = len(leaf_tree)
                if depth_iter >= max_srim_iters:
                    tree_str = "/".join(str(z) for z in leaf_tree)
                    print(
                        f"Skipping SRIM for Z={atomic_number} (path {tree_str}): "
                        f"reached max_srim_iters={max_srim_iters}"
                    )
                    continue

                run_branch(leaf_tree, batch)
                recurse(leaf_tree)

        batches = self.__separate_ions_by_atomic_number(
            energy_threshold=max_recoil_energy,
            atomic_numbers=atomic_numbers,
            energies=energies,
            depths=depths,
            ys=ys,
            zs=zs,
            cosxs=cosxs,
            cosys=cosys,
            coszs=coszs,
        )
        if not batches:
            print("No ions above the recoil energy threshold; nothing to run.")
            return

        for atomic_number, batch in batches.items():
            tree = (int(atomic_number),)
            run_branch(tree, batch)
            if max_srim_iters > 1:
                recurse(tree)

    # endregion
